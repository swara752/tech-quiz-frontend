<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TIC Tech Quiz - Waiting Room</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Orbitron:wght@400;500;700;900&display=swap"
        rel="stylesheet">
    <style>
        .bubbler-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 50%, #0f1629 100%);
        }

        .bubbler-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .bubbler-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .bubbler-header {
            text-align: center;
            padding: 3rem 2rem;
            background: linear-gradient(180deg, rgba(10, 14, 39, 0.95) 0%, rgba(10, 14, 39, 0) 100%);
        }

        .bubbler-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, #00f5ff 0%, #00d4ff 50%, #0099ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 30px rgba(0, 245, 255, 0.3);
            animation: glow-pulse 3s ease-in-out infinite;
        }

        .bubbler-subtitle {
            font-family: 'Inter', sans-serif;
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .bubbler-footer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 2rem;
            text-align: center;
            background: linear-gradient(0deg, rgba(10, 14, 39, 0.95) 0%, rgba(10, 14, 39, 0) 100%);
        }

        .bubbler-instruction {
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 1rem;
            animation: fade-in-out 2s ease-in-out infinite;
        }

        .bubbler-stats {
            display: flex;
            justify-content: center;
            gap: 3rem;
            margin-top: 1rem;
        }

        .stat-item {
            font-family: 'Orbitron', sans-serif;
        }

        .stat-label {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #00f5ff 0%, #00d4ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        @keyframes glow-pulse {

            0%,
            100% {
                filter: drop-shadow(0 0 20px rgba(0, 245, 255, 0.4));
            }

            50% {
                filter: drop-shadow(0 0 40px rgba(0, 245, 255, 0.8));
            }
        }

        @keyframes fade-in-out {

            0%,
            100% {
                opacity: 0.4;
            }

            50% {
                opacity: 1;
            }
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(0, 245, 255, 0.6);
            border-radius: 50%;
            pointer-events: none;
            animation: float-particle 3s linear infinite;
        }

        @keyframes float-particle {
            0% {
                transform: translateY(0) translateX(0);
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            90% {
                opacity: 1;
            }

            100% {
                transform: translateY(-100vh) translateX(50px);
                opacity: 0;
            }
        }

        /* TOP LEFT BRANDING */
        .header-branding {
            position: fixed;
            top: 25px;
            left: 25px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo-img {
            height: 60px;
            width: 60px;
            border-radius: 50%;
            border: 2px solid #00f5ff;
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.4);
            object-fit: cover;
        }

        .handle {
            font-family: 'Orbitron', sans-serif;
            color: #00f5ff;
            font-size: 1.2rem;
            text-shadow: 0 0 5px rgba(0, 245, 255, 0.5);
        }
    </style>
</head>

<body class="no-select">

    <div class="bg-grid"></div>
    <div class="bg-glow"></div>

    <div class="header-branding">
        <img src="tic-logo.jpg" alt="TIC Club" class="logo-img">
        <span class="handle">@TIC_Club</span>
    </div>

    <div class="bubbler-container">
        <canvas class="bubbler-canvas" id="bubbler-canvas"></canvas>

        <div class="bubbler-overlay">
            <div class="bubbler-header">
                <h1 class="bubbler-title">Best of Luck</h1>
                <div class="bubbler-subtitle">Game Starting Soon</div>
            </div>

            <div class="bubbler-footer">
                <div class="bubbler-instruction">
                    ✨ Click anywhere to create bubbles • Move your mouse to interact ✨
                </div>
                <div class="bubbler-stats">
                    <div class="stat-item">
                        <div class="stat-label">Bubbles</div>
                        <div class="stat-value" id="bubble-count">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Popped</div>
                        <div class="stat-value" id="popped-count">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Score</div>
                        <div class="stat-value" id="score-count">0</div>
                    </div>
                </div>

                <div style="margin-top: 30px; text-align: center;">
                    <div
                        style="font-family: 'Orbitron', sans-serif; font-size: 1rem; color: rgba(0,245,255,0.7); margin-bottom: 10px;">
                        QUIZ STARTS IN
                    </div>
                    <div id="countdown-timer" style="
                        font-family: 'Orbitron', sans-serif; 
                        font-size: 3rem; 
                        font-weight: 700; 
                        color: #fff;
                        text-shadow: 0 0 20px rgba(0, 245, 255, 0.6);
                    ">
                        05:00
                    </div>
                </div>

                <script>
                    (function () {
                        const duration = 2 * 60; // 2 minutes in seconds
                        const display = document.querySelector('#countdown-timer');
                        let timer = duration, minutes, seconds;

                        // Check if specific completion time exists
                        let targetTime = localStorage.getItem('bubblerTargetTime');
                        const now = Date.now();

                        // Set target if not set or expired
                        if (!targetTime || parseInt(targetTime) < now) {
                            targetTime = now + (duration * 1000);
                            localStorage.setItem('bubblerTargetTime', targetTime);
                        }

                        const interval = setInterval(function () {
                            const currentNow = Date.now();
                            const remaining = Math.max(0, Math.ceil((parseInt(targetTime) - currentNow) / 1000));

                            minutes = parseInt(remaining / 60, 10);
                            seconds = parseInt(remaining % 60, 10);

                            minutes = minutes < 10 ? "0" + minutes : minutes;
                            seconds = seconds < 10 ? "0" + seconds : seconds;

                            display.textContent = minutes + ":" + seconds;

                            if (remaining <= 0) {
                                clearInterval(interval);
                                window.location.href = 'round1.html';
                            }
                        }, 1000);
                    })();
                </script>
            </div>
        </div>
    </div>

    <script>
        /**
         * Interactive Bubbler - Waiting Room Entertainment
         * Participants can click to create bubbles and interact while waiting for quiz to start
         */

        const canvas = document.getElementById('bubbler-canvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Stats
        let stats = {
            bubbleCount: 0,
            poppedCount: 0,
            score: 0
        };

        // Bubble class
        class Bubble {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = Math.random() * 40 + 20; // 20-60px
                this.maxRadius = this.radius;
                this.speedY = -(Math.random() * 0.8 + 0.4); // Slower upward float
                this.speedX = (Math.random() - 0.5) * 0.8; // Reduced horizontal drift
                this.opacity = 1;
                this.hue = Math.random() * 60 + 180; // Blue-cyan range
                this.wobble = Math.random() * Math.PI * 2;
                this.wobbleSpeed = Math.random() * 0.03 + 0.01; // Slower wobble
                this.growing = true;
                this.growthRate = 0.5;
                this.popped = false;
                this.popAnimation = 0;
                this.glowIntensity = Math.random() * 0.5 + 0.5;
            }

            update() {
                if (this.popped) {
                    // Pop animation
                    this.popAnimation += 0.15;
                    this.radius += 3;
                    this.opacity -= 0.08;
                    return this.opacity > 0;
                }

                // Growth phase
                if (this.growing) {
                    this.radius += this.growthRate;
                    if (this.radius >= this.maxRadius) {
                        this.growing = false;
                    }
                }

                // Movement
                this.y += this.speedY;
                this.x += this.speedX + Math.sin(this.wobble) * 0.5;
                this.wobble += this.wobbleSpeed;

                // Fade out as it rises
                if (this.y < canvas.height * 0.3) {
                    this.opacity -= 0.005;
                }

                // Boundary check
                if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
                    this.speedX *= -0.8;
                }

                return this.opacity > 0 && this.y + this.radius > 0;
            }

            draw() {
                ctx.save();

                if (this.popped) {
                    // Pop effect - expanding ring
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `hsla(${this.hue}, 100%, 70%, ${this.opacity})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // Particles
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 * i) / 8;
                        const dist = this.popAnimation * 20;
                        const px = this.x + Math.cos(angle) * dist;
                        const py = this.y + Math.sin(angle) * dist;
                        ctx.beginPath();
                        ctx.arc(px, py, 3, 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, ${this.opacity})`;
                        ctx.fill();
                    }
                } else {
                    // Outer glow
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.radius * 1.5
                    );
                    gradient.addColorStop(0, `hsla(${this.hue}, 100%, 70%, ${this.opacity * 0.3 * this.glowIntensity})`);
                    gradient.addColorStop(0.5, `hsla(${this.hue}, 100%, 60%, ${this.opacity * 0.1 * this.glowIntensity})`);
                    gradient.addColorStop(1, `hsla(${this.hue}, 100%, 50%, 0)`);

                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 1.5, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();

                    // Main bubble
                    const bubbleGradient = ctx.createRadialGradient(
                        this.x - this.radius * 0.3, this.y - this.radius * 0.3, 0,
                        this.x, this.y, this.radius
                    );
                    bubbleGradient.addColorStop(0, `hsla(${this.hue}, 100%, 80%, ${this.opacity * 0.8})`);
                    bubbleGradient.addColorStop(0.4, `hsla(${this.hue}, 100%, 60%, ${this.opacity * 0.5})`);
                    bubbleGradient.addColorStop(1, `hsla(${this.hue}, 100%, 40%, ${this.opacity * 0.3})`);

                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = bubbleGradient;
                    ctx.fill();

                    // Highlight
                    ctx.beginPath();
                    ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.3, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity * 0.6})`;
                    ctx.fill();

                    // Rim
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `hsla(${this.hue}, 100%, 90%, ${this.opacity * 0.4})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                ctx.restore();
            }

            isClicked(mouseX, mouseY) {
                const dist = Math.hypot(mouseX - this.x, mouseY - this.y);
                return dist < this.radius;
            }

            pop() {
                if (!this.popped) {
                    this.popped = true;
                    stats.poppedCount++;
                    stats.score += Math.floor(this.maxRadius);
                    updateStats();
                    return true;
                }
                return false;
            }
        }

        // Bubble management
        let bubbles = [];
        let mouseX = 0;
        let mouseY = 0;
        let autoSpawnInterval;

        // Create ambient bubbles automatically
        function spawnAmbientBubble() {
            const x = Math.random() * canvas.width;
            const y = canvas.height + 50;
            bubbles.push(new Bubble(x, y));
            stats.bubbleCount++;
            updateStats();
        }

        // Start ambient spawning
        autoSpawnInterval = setInterval(spawnAmbientBubble, 800);

        // Mouse interaction
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('click', (e) => {
            const x = e.clientX;
            const y = e.clientY;

            // Check if clicked on existing bubble
            let clickedBubble = false;
            for (let i = bubbles.length - 1; i >= 0; i--) {
                if (bubbles[i].isClicked(x, y)) {
                    bubbles[i].pop();
                    clickedBubble = true;
                    break;
                }
            }

            // Create new bubble if not clicked on existing one
            if (!clickedBubble) {
                bubbles.push(new Bubble(x, y));
                stats.bubbleCount++;
                updateStats();
            }
        });

        // Touch support for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const x = touch.clientX;
            const y = touch.clientY;

            let clickedBubble = false;
            for (let i = bubbles.length - 1; i >= 0; i--) {
                if (bubbles[i].isClicked(x, y)) {
                    bubbles[i].pop();
                    clickedBubble = true;
                    break;
                }
            }

            if (!clickedBubble) {
                bubbles.push(new Bubble(x, y));
                stats.bubbleCount++;
                updateStats();
            }
        });

        // Update stats display
        function updateStats() {
            document.getElementById('bubble-count').textContent = stats.bubbleCount;
            document.getElementById('popped-count').textContent = stats.poppedCount;
            document.getElementById('score-count').textContent = stats.score;
        }

        // Background particles
        let particles = [];
        function createParticle() {
            const particle = {
                x: Math.random() * canvas.width,
                y: canvas.height,
                speed: Math.random() * 1 + 0.5,
                opacity: Math.random() * 0.5 + 0.3,
                size: Math.random() * 2 + 1
            };
            particles.push(particle);
        }

        setInterval(createParticle, 200);

        // Animation loop
        function animate() {
            // Clear with slight trail effect
            ctx.fillStyle = 'rgba(10, 14, 39, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update and draw particles
            particles = particles.filter(p => {
                p.y -= p.speed;
                p.x += Math.sin(p.y * 0.01) * 0.5;

                ctx.fillStyle = `rgba(0, 245, 255, ${p.opacity})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();

                return p.y > -10;
            });

            // Update and draw bubbles
            bubbles = bubbles.filter(bubble => {
                const alive = bubble.update();
                bubble.draw();
                return alive;
            });

            requestAnimationFrame(animate);
        }

        // Start animation
        animate();

        // Initial ambient bubbles
        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                spawnAmbientBubble();
            }, i * 300);
        }
    </script>
</body>

</html>